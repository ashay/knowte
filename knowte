#!/usr/bin/env ruby

# Knowte: A tool to record notes for compiling a research diary
# Copyright (C) 2010  Ashay Rane
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


#########################################################################
# TODO: Remove duplicate tags, not allow blank tags in retagging mechanism

require 'date'
require 'fileutils'


####################################
# FormattingConstants definitions
####################################

$editor = ENV['EDITOR']
DEFAULT_EDITOR = "vi"

if $editor.to_s.empty?
	$editor = DEFAULT_EDITOR.to_s
end

HOME_DIR = ENV['HOME'] +"/Dropbox/.rdir"
INTER_TAG_DELIM = ','
INTRA_TAG_DELIM = '-'
DATE_FIELD_DELIM= '-'
DATE_TAG_DELIM  = '^'

WINDOWS = false

if WINDOWS
	class FormattingConstants
		BLUE = ""
		GREEN = ""
		RED = ""
		BOLD = ""

		ENDFORMATTING = ""
	end
else
	class FormattingConstants
		BLUE = "\033[34m"
		GREEN = "\033[32m"
		RED = "\033[31m"
		BOLD = "\033[1m"

		ENDFORMATTING = "\033[0m"
	end
end


####################################
# Class definitions
####################################

class Misc
	def Misc.checkSetup()
		if !File::exists?(HOME_DIR.to_s)
			Dir.chdir(File.dirname(HOME_DIR.to_s))
			Dir.mkdir(File.basename(HOME_DIR.to_s))
			Dir.chdir(File.basename(HOME_DIR.to_s))
			Dir.mkdir(".archive")
		end
	end

	def Misc.printUsage()
		commands = [ FormattingConstants::BLUE + "new" + FormattingConstants::ENDFORMATTING + " [tags]", FormattingConstants::BLUE + "edit" + FormattingConstants::ENDFORMATTING + " [date / tags]", FormattingConstants::BLUE + "edit" + FormattingConstants::ENDFORMATTING + FormattingConstants::BLUE + " recent" + FormattingConstants::ENDFORMATTING, FormattingConstants::BLUE + "archive" + FormattingConstants::ENDFORMATTING + " [date / tags]", FormattingConstants::BLUE + "archive" + FormattingConstants::ENDFORMATTING + FormattingConstants::BLUE + " recent" + FormattingConstants::ENDFORMATTING, FormattingConstants::BLUE + "recover" + FormattingConstants::ENDFORMATTING + " [date / tags]", FormattingConstants::BLUE + "tag" + FormattingConstants::ENDFORMATTING + " [file/" + FormattingConstants::BLUE + "recent" + FormattingConstants::ENDFORMATTING + " " + FormattingConstants::BLUE + "+" + FormattingConstants::ENDFORMATTING + FormattingConstants::BLUE + "-" + FormattingConstants::ENDFORMATTING + " tags]]", FormattingConstants::BLUE + "list" + FormattingConstants::ENDFORMATTING + " [date / tags]", FormattingConstants::BLUE + "list recent" + FormattingConstants::ENDFORMATTING, FormattingConstants::BLUE + "list archive" + FormattingConstants::ENDFORMATTING, FormattingConstants::BLUE + "print" + FormattingConstants::ENDFORMATTING + " [date / tags]", FormattingConstants::BLUE + "print" + FormattingConstants::ENDFORMATTING + FormattingConstants::BLUE + " recent" + FormattingConstants::ENDFORMATTING, FormattingConstants::BLUE + "merge" + FormattingConstants::ENDFORMATTING + " [date / tags]" ]
		
		Formatting.printSpecial("USAGE: \n")

		for i in 0..commands.length-1 do
			Formatting.printSpecial(File.basename($0) + " ", "bold")
			Formatting.printSpecial(commands[i] + "\n")
		end
	end
	
	def Misc.driver()	# Main routine, I agree it is oddly named
		cliArguments = []
		cliArguments.replace(ARGV)
		ARGV.clear

		Misc.checkSetup()

		if cliArguments.length == 0
			Misc.printUsage()
			Process.exit
		end

		command = cliArguments.shift
		case command
			when "new" then	NoteHandler.newNote(cliArguments)
			when "edit" then	NoteHandler.edit(cliArguments)
			when "archive" then	NoteHandler.archive(cliArguments)
			when "tag" then	NoteHandler.tag(cliArguments)		# FIXME: Needs a revamp of syntax and implementation
			when "list" then	NoteHandler.list(cliArguments)
			when "print" then	NoteHandler.print(cliArguments)
			when "merge" then	NoteHandler.merge(cliArguments)
			when "recover" then	NoteHandler.recover(cliArguments)
			else NoteHandler.handleUnknownCommand(command)
		end
	end
end

class Formatting
	def Formatting.printSpecial(text, formatting="")
		case formatting
			when "bold" then
				printf FormattingConstants::BOLD + "%s" + FormattingConstants::ENDFORMATTING, text
			when "red" then
				printf FormattingConstants::RED + "%s" + FormattingConstants::ENDFORMATTING, text
			else
				printf text
		end
	end
	
	def Formatting.printErr(text)
		Formatting.printSpecial(text, "red")
	end
	
	def Formatting.splitQuottedStrings(inputString="")
		finalTags = []
		userInput = inputString.chomp.strip.gsub('"', '\'')
		splits = userInput.split('\'')
		for i in 0..splits.length-1
			if i % 2 == 1
				# Odd: Quotted strings
				newValue = splits[i].gsub(/[ \/]/, INTRA_TAG_DELIM.to_s).chom.strip
				if newValue.empty? == false
					finalTags.push newValue
				end
			else
				# Even: Non-quotted strings
				if splits [i].empty? == false
					nestedSplits = splits [i].chomp.strip.split(' ')
					for j in 0..nestedSplits.length-1
						newValue = nestedSplits[j].gsub(/[ \/]/, INTRA_TAG_DELIM.to_s).chomp.strip
						if newValue.empty? == false
							finalTags.push newValue
						end
					end
				end
			end
		end

		return finalTags
	end
	
	def Formatting.flattenParams(params, userInput=true)
		tags = []
		if params.length == 0
			if userInput == true
				printf "Tags: "
				return Formatting.splitQuottedStrings(gets())
			end
		else
			for i in 0..params.length-1
				tags[i] = params[i].gsub(/[ \/]/, INTRA_TAG_DELIM.to_s)
			end
		end

		return tags
	end
	
	def Formatting.formatFilename(filename, color=true, archiveSearch=false)
		fields = filename.split(DATE_TAG_DELIM)
		dateString = fields[0]

		if archiveSearch == false
			mTime = File::mtime(HOME_DIR.to_s + "/" + filename)
		else
			mTime = File::mtime(HOME_DIR.to_s + "/.archive/" + filename)
		end

		strMTime = mTime.strftime("%I:%M %p")

		tagString = fields[1..fields.length()-1].join(DATE_TAG_DELIM).gsub(INTER_TAG_DELIM.to_s, ', ')
		formattedString = dateString + " (" + strMTime + ")\t\t" + tagString.gsub(INTRA_TAG_DELIM.to_s, '-')

		if color
			return FormattingConstants::GREEN + formattedString + FormattingConstants::ENDFORMATTING
		else
			return formattedString
		end

	end
end

class FileSystemInterface
	def FileSystemInterface.editFile(filename)
		FileUtils.touch(filename)
		if system($editor + " \"" + filename + "\"") == false
			Formatting.printErr "Could not open editor: " + $editor.to_s + "\n"
			return 1
		end

		return 0
	end

	def FileSystemInterface.readFile(filename)
		fileContents = ""
		file = File.new(filename, "r")
		while (line = file.gets)
			fileContents += line
		end

		file.close
		return fileContents
	end

	def FileSystemInterface.writeFile(filename, fileContents)
		newFile = File.open(filename, File::WRONLY|File::TRUNC|File::CREAT)
		newFile.puts fileContents
		newFile.close
	end

 	def FileSystemInterface.getRecentFile()
		fileList = []
		# Search for the recently modified file
		Dir.foreach(HOME_DIR) do |entry|
			if entry != "." && entry != ".." && entry != ".archive"
				mTime = File::mtime(HOME_DIR.to_s + "/" + entry)
				fileList.push(mTime.strftime("%Y-%m-%d-%H-%M-%S") + "." + entry)
			end
		end

		fileList.sort!	# Sort itself
		fields = fileList.last.split('.')
		return fields [1..fields.length()-1].join('.')
	end
end

class TagProcessing
	def TagProcessing.processSpecialTags(searchTags=[])
		for i in 0..searchTags.length-1
			case searchTags[i].downcase
				when "today"
					date = DateTime.now
					searchTags.push(date.year.to_s + "-" + date.month.to_s + "-" + date.day.to_s)

				when "yesterday"
					date = DateTime.now-1
					searchTags.push(date.year.to_s + "-" + date.month.to_s + "-" + date.day.to_s)

				when "yest"
					date = DateTime.now-1
					searchTags.push(date.year.to_s + "-" + date.month.to_s + "-" + date.day.to_s)
			end
		end
	end

	def TagProcessing.findMatch(tags, searchTags=[])
		if searchTags.length == 0
			return true
		end

		# Does ANDing of search terms
		for i in 0..searchTags.length-1
			bFound = 0
			for j in 0..tags.length-1
				if (".*" + tags[j] + ".*").match(searchTags[i])
					bFound = 1
					break
				end
			end

			if bFound == 0
				return false
			end
		end

		return true
	end

	def TagProcessing.getTags(noteName="")
		tags = []
		if noteName != ""
			noteParts = noteName.split(DATE_TAG_DELIM)
			if noteParts [1] != nil
				tags.replace(noteParts[1].split(INTER_TAG_DELIM))
			end
		end

		return tags
	end
end

class Note
	def Note.edit(filename="")
		FileSystemInterface.editFile(filename)
	end
	
	def Note.archive(filename="")
		File.rename(HOME_DIR.to_s + "/" + filename, HOME_DIR.to_s + "/.archive/" + filename)
	end
	
	def Note.recover(filename="")
		File.rename(HOME_DIR.to_s + "/.archive/" + filename, HOME_DIR.to_s + "/" + filename)
		FileUtils.touch HOME_DIR.to_s + "/" + filename
	end

	def Note.tagNote(filename="", searchTags=[])
		tags = TagProcessing.getTags(filename)
		dateString = filename.split(DATE_TAG_DELIM)[0]

		if searchTags.empty?
			printf "Add(+) / Remove(-) tags (default: +)? "
			operation = gets.chomp
			if operation.empty?
				operation = "+"
			end
		else
			operation = searchTags.shift
		end

		if searchTags.empty?
			if operation == "+"
				printf "Tags to be added: "
			else
				printf "Tags to be removed: "
			end

			searchTags = Formatting.splitQuottedStrings(gets.chomp.strip)
			if searchTags.empty?
				return false
			end
		end

		if operation == "+"
			newTags = (tags | searchTags).uniq
		else
			tagFound = false
			for i in 0..searchTags.length-1
				if tags.include?(searchTags[i])
					tagFound = true
					break
				end		
			end

			if tagFound == false
				puts "The tag: \"" + searchTags[i] + "\" was not found to be associated with the note: " + Formatting.formatFilename(filename)+  ". Skipping this note.\n"
				return false
			end

			newTags = (tags - searchTags).uniq
		end

		newFilename = dateString + DATE_TAG_DELIM + newTags.join(INTER_TAG_DELIM.to_s)
		if newTags.length > 0 and File.exist?(HOME_DIR.to_s + "/" + newFilename)
			printf "A note with the tag(s) \"%s\" already exists. (Merge/overwrite/q)? ", FormattingConstants::GREEN + tags.join(', ') + FormattingConstants::ENDFORMATTING
			userInput = gets.chomp
			if userInput.empty? || userInput.downcase == "merge" || userInput.downcase == "m"
				Note.merge([filename, newFilename], newTags)
				return true
			else
				if userInput.downcase == "quit" || userInput.downcase == "q"
					return false
				else
					if userInput.downcase == "overwrite" || userInput.downcase = "o"
						File.rename(HOME_DIR.to_s + "/" + filename, HOME_DIR.to_s + "/" + dateString + DATE_TAG_DELIM + newTags.join(INTER_TAG_DELIM.to_s))
						return true
					end
				end
			end
		end

		if operation == "+"
			printf "Add tag(s) " + FormattingConstants::GREEN + searchTags.join(', ') + FormattingConstants::ENDFORMATTING + " for %s? (Y/n) ", Formatting.formatFilename(filename)
		else
			if operation == "-"
				if newTags.length == 0
					puts "Did not change tags because resulting set of tags was empty."
					return
				end

				printf "Remove tag(s) " + FormattingConstants::GREEN + searchTags.join(', ') + FormattingConstants::ENDFORMATTING + " for %s? (Y/n) ", Formatting.formatFilename(filename)
			else
				Formatting.printErr "Invalid command, expecting '+' or '-' after 'recent'\n"
				return
			end
		end

		userInput = gets.chomp
		if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
			File.rename(HOME_DIR.to_s + "/" + filename, HOME_DIR.to_s + "/" + dateString + DATE_TAG_DELIM + newTags.join(INTER_TAG_DELIM.to_s))
			return true
		else
			return false
		end
	end

	def Note.print(filename="")
		puts Formatting.formatFilename(filename)
		puts FileSystemInterface.readFile(HOME_DIR.to_s + "/" + filename)
		puts
	end
	
	def Note.merge(mergeFileList=[], newTags="")
		if mergeFileList.length > 1
			puts "\nMerging following notes: "
			for i in 0..mergeFileList.length-1 do
				puts Formatting.formatFilename(mergeFileList[i])
			end

			# Merge them
			finalString = ""
			for i in 0..mergeFileList.length-1 do
				finalString += Formatting.formatFilename(mergeFileList[i], false) + ":\n" + FileSystemInterface.readFile(HOME_DIR.to_s + "/" + mergeFileList[i]) + "\n"
			end

			date = DateTime.now
			filename = HOME_DIR.to_s + "/" + date.year.to_s + DATE_FIELD_DELIM + date.month.to_s + DATE_FIELD_DELIM + date.day.to_s + DATE_TAG_DELIM + newTags.join(INTER_TAG_DELIM.to_s)
			FileSystemInterface.writeFile(filename, finalString.chomp)

			# Open $editor
			if FileSystemInterface.editFile(filename) == 0
				# Delete old files
				for i in 0..mergeFileList.length-1 do
					if mergeFileList[i] != filename
						FileUtils.mv(HOME_DIR.to_s + "/" + mergeFileList[i], HOME_DIR.to_s + "/.archive/" + mergeFileList[i])
					end
				end
			end
			
			puts "Merged notes"
		else
			if mergeFileList.length == 1
				puts "Only one note matched your criteria: " + Formatting.formatFilename(mergeFileList[0]) + ". Cannot merge."
			else
				puts "No notes merged your criteria"
			end
		end
	end
end

class NoteHandler
	def NoteHandler.newNote(params=[])
		tagArray = Formatting.flattenParams(params)
		if tagArray.length != 0
			tagArray.uniq!
			tags = tagArray.join(INTER_TAG_DELIM.to_s)
			date = DateTime.now
			filename = HOME_DIR.to_s + "/" + date.year.to_s + DATE_FIELD_DELIM + date.month.to_s + DATE_FIELD_DELIM + date.day.to_s + DATE_TAG_DELIM + tags
			if FileSystemInterface.editFile(filename) == 0
				puts "Registered new note"
			end
		else
			puts "Did not register note. At least one tag is required."
		end
	end
	
	def NoteHandler.edit(params=[])
		searchTags = Formatting.flattenParams(params)
		fileList = NoteHandler.findRelevantNotes(searchTags)

		count = 0
		for i in 0..fileList.length-1
			filename = fileList[i]
			printf "Edit %s? (Y/n/q) ", Formatting.formatFilename(filename)
			userInput = gets.chomp
			if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
				FileSystemInterface.editFile(HOME_DIR.to_s + "/" + filename)
				count = count+1
			else
				if userInput.downcase == "quit" || userInput.downcase == "q"
					break
				end
			end
		end

		puts "Total " + count.to_s + " note(s) edited"
	end

	def NoteHandler.archive(params=[])
		searchTags = Formatting.flattenParams(params)
		fileList = NoteHandler.findRelevantNotes(searchTags)

		count = 0
		for i in 0..fileList.length-1
			entry = fileList[i]
			printf "Archive %s? (Y/n/q) ", Formatting.formatFilename(entry)
			userInput = gets.chomp
			if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
				Note.archive(entry)
				count = count+1
			else
				if userInput.downcase == "quit" || userInput.downcase == "q"
					break
				end
			end
		end

		puts "Total " + count.to_s + " note(s) archived"
	end
	
	def NoteHandler.recover(params=[])
		searchTags = Formatting.flattenParams(params)
		fileList = NoteHandler.findRelevantNotes(searchTags, true)	# Look into archive folder instead

		count = 0
		for i in 0..fileList.length-1
			entry = fileList[i]
			printf "Recover %s? (Y/n/q) ", Formatting.formatFilename(entry, true, true)
			userInput = gets.chomp
			if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
				Note.recover(entry)
				count = count+1
			else
				if userInput.downcase == "quit" || userInput.downcase == "q"
					break
				end
			end
		end

		puts "Total " + count.to_s + " note(s) recovered"
	end
	
	# FIXME: Needs a revamp of syntax and implementation
	def NoteHandler.tag(params=[])
 		searchTags = Formatting.flattenParams(params, false)

		noteMatchTags = []
 		for i in 0..searchTags.length-1
 			if searchTags[0] != "+" && searchTags[0] != "-"
 				noteMatchTags.push searchTags.shift
 			else
 				break
 			end
 		end

		count = 0
		fileList = NoteHandler.findRelevantNotes(noteMatchTags)
		for i in 0..fileList.length-1
			entry = fileList[i]
			printf "Tag %s? (Y/n/q) ", Formatting.formatFilename(entry)
			userInput = gets.chomp
			if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
				if Note.tagNote(fileList[i], searchTags) == true
					count = count+1
				end
			else
				if userInput.downcase == "quit" || userInput.downcase == "q"
					break
				end
			end
		end
 
 		puts "Changed tags for " + count.to_s + " note(s)"
	end
	
	def NoteHandler.findRelevantNotes(searchTags=[], archiveFolder=false)
		matchingFiles = Array.new
		TagProcessing.processSpecialTags(searchTags)

		searchFolder = HOME_DIR.to_s
		if archiveFolder == false
			if searchTags[0] == "recent"
				filename = FileSystemInterface.getRecentFile()
				if filename != ""
					matchingFiles.push(filename)
				end

				return matchingFiles
			end
		else
			# Searching in the archive folder
			searchFolder = searchFolder + "/.archive/"
		end

		Dir.foreach(searchFolder) do |entry|
			if entry != "." && entry != ".." && entry != ".archive"
				fields = entry.split(DATE_TAG_DELIM)
				dateString = fields[0]
				tagString = fields[1..fields.length()-1].join(DATE_TAG_DELIM).gsub(INTER_TAG_DELIM.to_s, ', ')
				tags = tagString.split(INTER_TAG_DELIM.to_s)
				tags.push dateString

				if (TagProcessing.findMatch(tags, searchTags))
					matchingFiles.push(entry)
				end
			end
		end

		return matchingFiles
	end

	def NoteHandler.list(params=[])
		searchTags = Formatting.flattenParams(params)

		if searchTags [0] == "archive"
			searchTags.shift
			archiveSearch = true
		else
			archiveSearch = false
		end

		fileList = NoteHandler.findRelevantNotes(searchTags, archiveSearch)

		fileList.sort!
		for i in 0..fileList.length-1
			# Showing most recent note first
			puts Formatting.formatFilename(fileList[fileList.length-1-i], true, archiveSearch)	# Searching in the archive folder
		end

		puts "Total " + fileList.count.to_s + " note(s) displayed"
	end
	
	def NoteHandler.print(params=[])
		searchTags = Formatting.flattenParams(params)

		fileList = NoteHandler.findRelevantNotes(searchTags)
		for i in 0..fileList.length-1
			Note.print(fileList[i])
		end

		puts "Total " + fileList.length.to_s + " notes(s)"
	end
	
	def NoteHandler.merge(params=[])
		searchTags = Formatting.flattenParams(params)

		newTags = []
		noteTags = []
		mergeFileList = []
		fileList = NoteHandler.findRelevantNotes(searchTags)
		for i in 0..fileList.count-1
			entry = fileList [i]
			printf "Use " + Formatting.formatFilename(entry) + " for merging? (Y/n/q) "
			userInput = gets.chomp.strip
			if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
				newTags = newTags | TagProcessing.getTags(entry)
				mergeFileList.push entry
			else
				if userInput.downcase == "quit" || userInput.downcase == "q"
					break
				end
			end
		end

		Note.merge(mergeFileList, newTags)
	end
	
	def NoteHandler.handleUnknownCommand(command)
		puts "Unknown command: '" + command + "'"
		Process.exit
	end
end

Misc.driver()
