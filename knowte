#!/home/ashayrane/apps/bin/ruby

# Knowte: A tool to record notes for compiling a research diary
# Copyright (C) 2009  Ashay Rane
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


require 'date'
require 'fileutils'

$editor = ENV['EDITOR']
DEFAULT_EDITOR = "vi"

if $editor.to_s.empty?
	$editor = DEFAULT_EDITOR.to_s
end

HOME_DIR = ENV['HOME'] +"/.rdir"
INTER_TAG_DELIM = ','
INTRA_TAG_DELIM = '-'

cliArguments = []
cliArguments.replace(ARGV)
ARGV.clear

def checkSetup()
	if !File::exists?(HOME_DIR.to_s)
		Dir.chdir(File.dirname(HOME_DIR.to_s))
		Dir.mkdir(File.basename(HOME_DIR.to_s))
		Dir.chdir(File.basename(HOME_DIR.to_s))
		Dir.mkdir(".archive")
	end
end

def printUsage ()
	commands = [ "\033[10;34mnew\033[0m [tags]", "\033[10;34medit\033[0m date / tags", "\033[10;34medit\033[0m \033[10;34mrecent\033[0m", "\033[10;34marchive\033[0m date / tags", "\033[10;34marchive\033[0m \033[10;34mrecent\033[0m", "\033[10;34mrecover\033[0m date / tags", "\033[10;34mtag\033[0m [file/\033[10;34mrecent\033[0m [\033[10;34m+\033[0m/\033[10;34m-\033[0m tags]]", "\033[10;34mlist\033[0m [date / tags]", "\033[10;34mprint\033[0m date / tags", "\033[10;34mprint\033[0m \033[10;34mrecent\033[0m", "\033[10;34mmerge\033[0m date / tags" ]
	printSpecial("USAGE: \n")

	for i in 0..commands.length-1 do
		printSpecial(File.basename($0) + " ", "bold")
		printSpecial(commands[i] + "\n")
	end
end

def printSpecial (text, formatting="")
	case formatting
		when "bold" then
			printf "\033[1m%s\033[0m", text
		when "red" then
			printf "\033[31m%s\033[0m", text
		else
			printf text
	end
end

def printErr (text)
	printSpecial(text, "red")
end

def findMatch(tags, searchTags=[])
	if searchTags.length == 0
		return true
	end

	for i in 0..searchTags.length-1
		for j in 0..tags.length-1
			if tags[j].include?(searchTags[i])
				return true
			end
		end
	end

	return false
end

def splitQuottedStrings(inputString="")
	finalTags = []
	userInput = inputString.chomp.strip.gsub('"', '\'')
	splits = userInput.split('\'')
	for i in 0..splits.length-1
		if i % 2 == 1
			# Odd: Quotted strings
			newValue = splits[i].gsub(/[ \/]/, INTRA_TAG_DELIM.to_s).chom.strip
			if newValue.empty? == false
				finalTags.push newValue
			end
		else
			# Even: Non-quotted strings
			if splits [i].empty? == false
				nestedSplits = splits [i].chomp.strip.split(' ')
				for j in 0..nestedSplits.length-1
					newValue = nestedSplits[j].gsub(/[ \/]/, INTRA_TAG_DELIM.to_s).chomp.strip
					if newValue.empty? == false
						finalTags.push newValue
					end
				end
			end
		end
	end

	return finalTags
end

def flattenParams(params, userInput=true)
	tags = []
	if params.length == 0
		if userInput == true
			printf "Tags: "
			return splitQuottedStrings(gets())
		end
	else
		for i in 0..params.length-1
			tags[i] = params[i].gsub(/[ \/]/, INTRA_TAG_DELIM.to_s)
		end
	end

	return tags
end

def formatFilename(filename, color=true)
	fields = filename.split('*')
	dateString = fields[0]
	tagString = fields[1..fields.length()-1].join('*').gsub(INTER_TAG_DELIM.to_s, ', ')
	formattedString = dateString + "\t" + tagString.gsub(INTRA_TAG_DELIM.to_s, '-')

	if color == true
		return "\033[32m" + formattedString + "\033[0m"
	else
		return formattedString;
	end
end

def editFile(filename)
	FileUtils.touch(filename)
	if system($editor + " " + filename) == false
		printErr "Could not open editor: " + $editor.to_s + "\n"
		return 1
	end

	return 0
end

def new(params=[])
	tagArray = flattenParams(params)
	tags = tagArray.join(INTER_TAG_DELIM.to_s)
	date = DateTime.now
	filename = HOME_DIR.to_s + "/" + date.year.to_s + ":" + date.month.to_s + ":" + date.day.to_s + "*" + tags
	if editFile(filename) == 0
		puts "Registered new note"
	end
end

def getRecentFile()
	fileList = []
	# Search for the recently modified file
	Dir.foreach(HOME_DIR) do |entry|
		if entry != "." && entry != ".." && entry != ".archive"
			mTime = File::mtime(HOME_DIR.to_s + "/" + entry)
			fileList.push(mTime.strftime("%Y-%m-%d-%H-%M-%S") + "." + entry)
		end
	end

	fileList.sort!	# Sort itself
	return fileList.last.split('.')[1]
end

def edit(params=[])
	searchTags = flattenParams(params)

	if searchTags[0] == "recent"
		filename = getRecentFile()
		if filename != ""
			printf "Edit %s? (Y/n) ", formatFilename(filename)
			userInput = gets.chomp
			if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
				editFile(HOME_DIR.to_s + "/" + filename)
				puts "Note edited"
			end
		else
			printErr "Could not find any recently edited note\n"
		end

		return
	end

	count = 0
	userInput = ""
	Dir.foreach(HOME_DIR) do |entry|
		if entry != "." && entry != ".." && entry != ".archive"
			fields = entry.split('*')
			dateString = fields[0]
			tagString = fields[1..fields.length()-1].join('*').gsub(INTER_TAG_DELIM.to_s, ', ')
			tags = tagString.split(INTER_TAG_DELIM.to_s)
			tags.push dateString

			if (findMatch(tags, searchTags))
				printf "Edit %s? (Y/n) ", formatFilename(entry)
				userInput = gets.chomp
				if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
					editFile(HOME_DIR.to_s + "/" + entry)
					count = count+1
				end
			end
		end
	end

	puts "Total " + count.to_s + " note(s) edited"
end

def archive(params=[])
	searchTags = flattenParams(params)

	if searchTags[0] == "recent"
		filename = getRecentFile()
		if filename != ""
			printf "Archive %s? (Y/n) ", formatFilename(filename)
			userInput = gets.chomp
			if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
				File.rename(HOME_DIR.to_s + "/" + filename, HOME_DIR.to_s + "/.archive/" + filename)
				puts "Note archived"
			else
				puts "Archive aborted"
			end
		else
			printErr "Could not find any recently edited note\n"
		end
		return
	end

	count = 0
	userInput = ""
	Dir.foreach(HOME_DIR) do |entry|
		if entry != "." && entry != ".." && entry != ".archive"
			fields = entry.split('*')
			dateString = fields[0]
			tagString = fields[1..fields.length()-1].join('*').gsub(INTER_TAG_DELIM.to_s, ', ')
			tags = tagString.split(INTER_TAG_DELIM.to_s)
			tags.push dateString

			if (findMatch(tags, searchTags))
				printf "Archive %s? (Y/n) ", formatFilename(entry)
				userInput = gets.chomp
				if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
					File.rename(HOME_DIR.to_s + "/" + entry, HOME_DIR.to_s + "/.archive/" + entry)
					count = count+1
				end
			end
		end
	end

	puts "Total " + count.to_s + " note(s) archived"
end

def recover(params=[])
	searchTags = flattenParams(params)

	count = 0
	Dir.foreach(HOME_DIR + "/.archive") do |entry|
		if entry != "." && entry != ".."
			fields = entry.split('*')
			dateString = fields[0]
			tagString = fields[1..fields.length()-1].join('*').gsub(INTER_TAG_DELIM.to_s, ', ')
			tags = tagString.split(INTER_TAG_DELIM.to_s)
			tags.push dateString

			if (findMatch(tags, searchTags))
				printf "Recover %s? (Y/n) ", formatFilename(entry)
				userInput = gets.chomp
				if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
					File.rename(HOME_DIR.to_s + "/.archive/" + entry, HOME_DIR.to_s + "/" + entry)
					FileUtils.touch HOME_DIR.to_s + "/" + entry
					count = count+1
				end
			end
		end
	end

	puts "Total " + count.to_s + " note(s) recovered"
end

def tagSingleNote(filename, searchTags)
	fields = filename.split('*')
	dateString = fields[0]
	tagString = fields[1..fields.length()-1].join('*').gsub(INTER_TAG_DELIM.to_s, ', ')
	tags = tagString.split(INTER_TAG_DELIM.to_s)

	if searchTags.empty?
		printf "Add(+) / Remove(-) tags (default: +)? "
		operation = gets.chomp
		if operation.empty?
			operation = "+"
		end
	else
		operation = searchTags.shift
	end

	if searchTags.empty?
		printf "Tags to be added or removed: "
		searchTags = splitQuottedStrings(gets.chomp.strip)
		if searchTags.empty?
			return false
		end
	end

	if operation == "+"
		# Add tag
		tags = tags | searchTags
		printf "Add tag(s) \033[10;32m" + searchTags.join(', ') + "\033[0m for %s? (Y/n) ", formatFilename(filename)
	else
		if operation == "-"
			# Remove tag
			tags = tags - searchTags
			printf "Remove tag(s) \033[10;32m" + searchTags.join(', ') + "\033[0m for %s? (Y/n) ", formatFilename(filename)
		else
			printErr "Invalid command, expecting '+' or '-' after 'recent'\n"
			return false
		end
	end

	userInput = gets.chomp
	if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
		File.rename(HOME_DIR.to_s + "/" + filename, HOME_DIR.to_s + "/" + dateString + "*" + tags.join(INTER_TAG_DELIM.to_s))
		return true
	else
		return false
	end
end

def tag(params=[])
	searchTags = flattenParams(params, false)
	
	if searchTags[0] == "recent"
		filename = getRecentFile()
		if filename != ""
			if tagSingleFile(filename, searchTags) == true
				puts "Tags changed"
			else
				puts "Aborted changing tags"
			end
		else
			printErr "Could not find any recently edited note\n"
		end

		return
	end

	count = 0
	userInput = ""

	noteMatchTags=[]
	if searchTags.empty?
		printf "Tags to identify source note: "
		searchTags = splitQuottedStrings(gets.strip.chomp)
	end

	for i in 0..searchTags.length-1
		if searchTags[0] != "+" && searchTags[0] != "-"
			noteMatchTags.push searchTags.shift
		else
			break
		end
	end

	# if noteMatchTags.length == searchTags.length
	#	printErr "Incorrect syntax, expecting a +/- and at least one tag\n"
	#	return
	# end

	Dir.foreach(HOME_DIR) do |entry|
		if entry != "." && entry != ".." && entry != ".archive"
			fields = entry.split('*')
			dateString = fields[0]
			tagString = fields[1..fields.length()-1].join('*').gsub(INTER_TAG_DELIM.to_s, ', ')
			tags = tagString.split(INTER_TAG_DELIM.to_s)
			tags.push dateString

			if (findMatch(tags, noteMatchTags))
				if tagSingleNote(entry, searchTags) == true
					count = count+1
				end
			end
		end
	end

	puts "Changed tags for " + count.to_s + " note(s)"
end

def list(params=[])
	searchTags = flattenParams(params)

	count = 0
	fileList = []
	Dir.foreach(HOME_DIR) do |entry|
		if entry != "." && entry != ".." && entry != ".archive"
			fields = entry.split('*')
			dateString = fields[0]
			tagString = fields[1..fields.length()-1].join('*').gsub(INTER_TAG_DELIM.to_s, ', ')
			tags = tagString.split(INTER_TAG_DELIM.to_s)
			tags.push dateString

			if (findMatch(tags, searchTags))
				mTime = File::mtime(HOME_DIR.to_s + "/" + entry)
				fileList.push(mTime.strftime("%Y-%m-%d-%H-%M-%S") + "." + entry)
				# puts formatFilename(entry)
				count = count+1
			end
		end
	end

	fileList.sort!
	for i in 0..fileList.length-1
		parts = fileList[fileList.length-1-i].split('.')
		parts.shift
		puts formatFilename(parts.join)
	end

	puts "Total " + count.to_s + " note(s) displayed"
end

def readFile(filename)
	fileContents = ""
	file = File.new(filename, "r")
	while (line = file.gets)
	#	fileContents = fileContents + line
		fileContents += line
	end

	file.close
	return fileContents
end

def writeFile(filename, fileContents="")
	newFile = File.open(filename, File::WRONLY|File::TRUNC|File::CREAT)
	newFile.puts fileContents
	newFile.close
end

def print(params=[])
	searchTags = flattenParams(params)

	if searchTags[0] == "recent"
		filename = getRecentFile()
		if filename != ""
			puts formatFilename(filename)
			puts readFile(HOME_DIR.to_s + "/" + filename)
			puts
		else
			printErr "Could not find any recently edited note\n"
		end

		return
	end

	count = 0
	Dir.foreach(HOME_DIR) do |entry|
		if entry != "." && entry != ".." && entry != ".archive"
			fields = entry.split('*')
			dateString = fields[0]
			tagString = fields[1..fields.length()-1].join('*').gsub(INTER_TAG_DELIM.to_s, ', ')
			tags = tagString.split(INTER_TAG_DELIM.to_s)
			tags.push dateString

			if (findMatch(tags, searchTags))
				puts formatFilename(entry)
				puts readFile(HOME_DIR.to_s + "/" + entry)
				puts
				count = count+1
			end
		end
	end

	puts "Total " + count.to_s + " notes(s)"
end

def merge(params=[])
	searchTags = flattenParams(params)

	count = 0
	fileList = []
	origTags = []
	newTags = []
	Dir.foreach(HOME_DIR) do |entry|
		if entry != "." && entry != ".." && entry != ".archive"
			fields = entry.split('*')
			dateString = fields[0]
			tagString = fields[1..fields.length()-1].join('*').gsub(INTER_TAG_DELIM.to_s, ', ')
			tags = tagString.split(INTER_TAG_DELIM.to_s)
			origTags.replace(tags)
			tags.push dateString

			if (findMatch(tags, searchTags))
				printf "Use " + formatFilename(entry) + " for merging? (Y/n) "
				userInput = gets.chomp.strip
				if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
					newTags = newTags | origTags
					fileList.push entry
					count = count+1
				end
			end
		end
	end

	if count > 1
		puts "\nMerging following notes: "
		for i in 0..fileList.length-1 do
			puts formatFilename(fileList[i])
		end

		# printf "\nProceed? (Y/n) "
		# userInput = gets.chomp
		# if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
		# Merge them
		finalString = ""
		for i in 0..fileList.length-1 do
			finalString += formatFilename(fileList[i], false) + ":\n" + readFile(HOME_DIR.to_s + "/" + fileList[i]) + "\n"
		end

		date = DateTime.now
		filename = HOME_DIR.to_s + "/" + date.year.to_s + ":" + date.month.to_s + ":" + date.day.to_s + "*" + newTags.join(INTER_TAG_DELIM.to_s)
		writeFile(filename, finalString.chomp)

		# Open $editor
		if editFile(filename) == 0
			# Delete old files
			for i in 0..fileList.length-1 do
				if fileList[i] != filename
					File.rename(HOME_DIR.to_s + "/" + fileList[i], HOME_DIR.to_s + "/.archive/" + fileList[i])
				end
			end
		end
		
		puts "Merged notes"
		# else
		# 	puts "Aborted merging notes"
		# end
	else
		if count == 1
			puts "Only one note matched your criteria: " + formatFilename(fileList[0])
		else
			puts "No notes merged your criteria"
		end
	end
end

checkSetup()

if cliArguments.length == 0
	printUsage()
	Process.exit
end

case cliArguments.shift
	when "new" then		new(cliArguments)
	when "edit" then	edit(cliArguments)
	when "archive" then	archive(cliArguments)
	when "tag" then		tag(cliArguments)
	when "list" then	list(cliArguments)
	when "print" then	print(cliArguments)
	when "merge" then	merge(cliArguments)
	when "recover" then	recover(cliArguments)
end
