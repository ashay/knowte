#!/usr/bin/env ruby

# Knowte: A tool to record notes for compiling a research diary
# Copyright (C) 2010  Ashay Rane
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


#########################################################################
# TODO: Remove duplicate tags, not allow blank tags in retagging mechanism

require 'date'
require 'fileutils'


####################################
# Constants definitions
####################################

$editor = ENV['EDITOR']
DEFAULT_EDITOR = "notepad"

if $editor.to_s.empty?
	$editor = DEFAULT_EDITOR.to_s
end

HOME_DIR = ENV['HOME'] +"/.rdir"
INTER_TAG_DELIM = ','
INTRA_TAG_DELIM = '-'

WINDOWS = false

if WINDOWS
	DATE_TAG_DELIM  = '$'
	DATE_FIELD_DELIM= '-'
	NOCOLOR = true
else
	DATE_TAG_DELIM  = '*'
	DATE_FIELD_DELIM= '-'
	NOCOLOR = false
end


####################################
# Class definitions
####################################

class Misc
	def Misc.checkSetup()
		if !File::exists?(HOME_DIR.to_s)
			Dir.chdir(File.dirname(HOME_DIR.to_s))
			Dir.mkdir(File.basename(HOME_DIR.to_s))
			Dir.chdir(File.basename(HOME_DIR.to_s))
			Dir.mkdir(".archive")
		end
	end

	def Misc.printUsage()
		if NOCOLOR
			commands = [ "new [tags]", "edit [date / tags]", "edit recent", "archive [date / tags]", "archive recent", "recover [date / tags]", "tag [file/recent [+/- tags]]", "list [date / tags]", "list recent", "list archive", "print [date / tags]", "print recent", "merge [date / tags]" ]
		else
			commands = [ "\033[10;34mnew\033[0m [tags]", "\033[10;34medit\033[0m [date / tags]", "\033[10;34medit\033[0m \033[10;34mrecent\033[0m", "\033[10;34marchive\033[0m [date / tags]", "\033[10;34marchive\033[0m \033[10;34mrecent\033[0m", "\033[10;34mrecover\033[0m [date / tags]", "\033[10;34mtag\033[0m [file/\033[10;34mrecent\033[0m [\033[10;34m+\033[0m/\033[10;34m-\033[0m tags]]", "\033[10;34mlist\033[0m [date / tags]", "\033[10;34mlist recent\033[0m", "\033[10;34mlist archive\033[0m", "\033[10;34mprint\033[0m [date / tags]", "\033[10;34mprint\033[0m \033[10;34mrecent\033[0m", "\033[10;34mmerge\033[0m [date / tags]" ]
		end
		
		Formatting.printSpecial("USAGE: \n")

		for i in 0..commands.length-1 do
			Formatting.printSpecial(File.basename($0) + " ", "bold")
			Formatting.printSpecial(commands[i] + "\n")
		end
	end
	
	def Misc.driver()	# Main routine, I agree it is oddly named
		cliArguments = []
		cliArguments.replace(ARGV)
		ARGV.clear

		Misc.checkSetup()

		if cliArguments.length == 0
			Misc.printUsage()
			Process.exit
		end

		command = cliArguments.shift
		case command
			when "new" then	NoteHandler.newNote(cliArguments)
			when "edit" then	NoteHandler.edit(cliArguments)
			when "archive" then	NoteHandler.archive(cliArguments)
			when "tag" then	NoteHandler.tag(cliArguments)		# FIXME: Needs a revamp of syntax and implementation
			when "list" then	NoteHandler.list(cliArguments)
			when "print" then	NoteHandler.print(cliArguments)
			when "merge" then	NoteHandler.merge(cliArguments)
			when "recover" then	NoteHandler.recover(cliArguments)
			else NoteHandler.handleUnknownCommand(command)
		end
	end
end

class Formatting
	def Formatting.printSpecial(text, formatting="")
		if NOCOLOR
			printf text
		else
			case formatting
				when "bold" then
					printf "\033[1m%s\033[0m", text
				when "red" then
					printf "\033[31m%s\033[0m", text
				else
					printf text
			end
		end
	end
	
	def Formatting.printErr(text)
		Formatting.printSpecial(text, "red")
	end
	
	def Formatting.splitQuottedStrings(inputString="")
		finalTags = []
		userInput = inputString.chomp.strip.gsub('"', '\'')
		splits = userInput.split('\'')
		for i in 0..splits.length-1
			if i % 2 == 1
				# Odd: Quotted strings
				newValue = splits[i].gsub(/[ \/]/, INTRA_TAG_DELIM.to_s).chom.strip
				if newValue.empty? == false
					finalTags.push newValue
				end
			else
				# Even: Non-quotted strings
				if splits [i].empty? == false
					nestedSplits = splits [i].chomp.strip.split(' ')
					for j in 0..nestedSplits.length-1
						newValue = nestedSplits[j].gsub(/[ \/]/, INTRA_TAG_DELIM.to_s).chomp.strip
						if newValue.empty? == false
							finalTags.push newValue
						end
					end
				end
			end
		end

		return finalTags
	end
	
	def Formatting.flattenParams(params, userInput=true)
		tags = []
		if params.length == 0
			if userInput == true
				printf "Tags: "
				return Formatting.splitQuottedStrings(gets())
			end
		else
			for i in 0..params.length-1
				tags[i] = params[i].gsub(/[ \/]/, INTRA_TAG_DELIM.to_s)
			end
		end

		return tags
	end
	
	def Formatting.formatFilename(filename, color=true)
		fields = filename.split(DATE_TAG_DELIM)
		dateString = fields[0]
		
		if WINDOWS
			dateString = dateString.gsub(DATE_FIELD_DELIM, '-')
		end
		
		tagString = fields[1..fields.length()-1].join(DATE_TAG_DELIM).gsub(INTER_TAG_DELIM.to_s, ', ')
		formattedString = dateString + "\t" + tagString.gsub(INTRA_TAG_DELIM.to_s, '-')

		if NOCOLOR
			return formattedString;
		else
			# Check if the caller specifically requested coloring
			if color == true
				return "\033[32m" + formattedString + "\033[0m"
			else
				return formattedString;
			end
		end
	end
end

class FileSystemInterface
	def FileSystemInterface.editFile(filename)
		FileUtils.touch(filename)
		if system($editor + " " + filename) == false
			Formatting.printErr "Could not open editor: " + $editor.to_s + "\n"
			return 1
		end

		return 0
	end

	def FileSystemInterface.readFile(filename)
		fileContents = ""
		file = File.new(filename, "r")
		while (line = file.gets)
			fileContents += line
		end

		file.close
		return fileContents
	end

	def FileSystemInterface.writeFile(filename, fileContents)
		newFile = File.open(filename, File::WRONLY|File::TRUNC|File::CREAT)
		newFile.puts fileContents
		newFile.close
	end

 	def FileSystemInterface.getRecentFile()
		fileList = []
		# Search for the recently modified file
		Dir.foreach(HOME_DIR) do |entry|
			if entry != "." && entry != ".." && entry != ".archive"
				mTime = File::mtime(HOME_DIR.to_s + "/" + entry)
				fileList.push(mTime.strftime("%Y-%m-%d-%H-%M-%S") + "." + entry)
			end
		end

		fileList.sort!	# Sort itself
		fields = fileList.last.split('.')
		return fields [1..fields.length()-1].join('.')
	end
end

class TagProcessing
	def TagProcessing.findMatch(tags, searchTags=[])
		if searchTags.length == 0
			return true
		end

		for i in 0..searchTags.length-1
			for j in 0..tags.length-1
				if tags[j].include?(searchTags[i])
					return true
				end
			end
		end

		return false
	end

	def TagProcessing.getTags(noteName="")
		tags = []
		if noteName != ""
			noteParts = noteName.split(DATE_TAG_DELIM)
			if noteParts [1] != nil
				tags.replace(noteParts[1].split(INTER_TAG_DELIM))
			end
		end

		return tags
	end
end

class Note
	def Note.edit(filename="")
		FileSystemInterface.editFile(filename)
	end
	
	def Note.archive(filename="")
		File.rename(HOME_DIR.to_s + "/" + filename, HOME_DIR.to_s + "/.archive/" + filename)
	end
	
	def Note.recover(filename="")
		File.rename(HOME_DIR.to_s + "/.archive/" + filename, HOME_DIR.to_s + "/" + filename)
		FileUtils.touch HOME_DIR.to_s + "/" + filename
	end

	def Note.tagNote(filename="", searchTags=[])
		tags = TagProcessing.getTags(filename)
		dateString = filename.split(DATE_TAG_DELIM)[0]

		if searchTags.empty?
			printf "Add(+) / Remove(-) tags (default: +)? "
			operation = gets.chomp
			if operation.empty?
				operation = "+"
			end
		else
			operation = searchTags.shift
		end

		if searchTags.empty?
			if operation == "+"
				printf "Tags to be added: "
			else
				printf "Tags to be removed: "
			end

			searchTags = Formatting.splitQuottedStrings(gets.chomp.strip)
			if searchTags.empty?
				return false
			end
		end

		if operation == "+"
			# Add tag
			tags = tags | searchTags

			if NOCOLOR
				printf "Add tag(s) \'" + searchTags.join('\', \'') + "\' for %s? (Y/n) ", Formatting.formatFilename(filename)
			else
				printf "Add tag(s) \033[10;32m" + searchTags.join(', ') + "\033[0m for %s? (Y/n) ", Formatting.formatFilename(filename)
			end
		else
			if operation == "-"
				# Remove tag
				tags = tags - searchTags

				tags.uniq!
				if tags.length == 0
					puts "Did not change tags because resulting set of tags was empty."
					return false
				end

				if NOCOLOR
					printf "Remove tag(s) " + searchTags.join(', ') + " for %s? (Y/n) ", Formatting.formatFilename(filename)
				else
					printf "Remove tag(s) \033[10;32m" + searchTags.join(', ') + "\033[0m for %s? (Y/n) ", Formatting.formatFilename(filename)
				end			
			else
				Formatting.printErr "Invalid command, expecting '+' or '-' after 'recent'\n"
				return false
			end
		end

		userInput = gets.chomp
		if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
			File.rename(HOME_DIR.to_s + "/" + filename, HOME_DIR.to_s + "/" + dateString + DATE_TAG_DELIM + tags.join(INTER_TAG_DELIM.to_s))
			return true
		else
			return false
		end
	end

	def Note.print(filename="")
		puts Formatting.formatFilename(filename)
		puts FileSystemInterface.readFile(HOME_DIR.to_s + "/" + filename)
		puts
	end
	
	def Note.merge(mergeFileList=[], newTags="")
		if mergeFileList.length > 1
			puts "\nMerging following notes: "
			for i in 0..mergeFileList.length-1 do
				puts Formatting.formatFilename(mergeFileList[i])
			end

			# Merge them
			finalString = ""
			for i in 0..mergeFileList.length-1 do
				finalString += Formatting.formatFilename(mergeFileList[i], false) + ":\n" + FileSystemInterface.readFile(HOME_DIR.to_s + "/" + mergeFileList[i]) + "\n"
			end

			date = DateTime.now
			filename = HOME_DIR.to_s + "/" + date.year.to_s + DATE_FIELD_DELIM + date.month.to_s + DATE_FIELD_DELIM + date.day.to_s + DATE_TAG_DELIM + newTags.join(INTER_TAG_DELIM.to_s)
			FileSystemInterface.writeFile(filename, finalString.chomp)

			# Open $editor
			if FileSystemInterface.editFile(filename) == 0
				# Delete old files
				for i in 0..mergeFileList.length-1 do
					if mergeFileList[i] != filename
						File.rename(HOME_DIR.to_s + "/" + mergeFileList[i], HOME_DIR.to_s + "/.archive/" + mergeFileList[i])
					end
				end
			end
			
			puts "Merged notes"
		else
			if mergeFileList.length == 1
				puts "Only one note matched your criteria: " + Formatting.formatFilename(fileList[0])
			else
				puts "No notes merged your criteria"
			end
		end
	end
end

class NoteHandler
	def NoteHandler.newNote(params=[])
		tagArray = Formatting.flattenParams(params)
		if tagArray.length != 0
			tagArray.uniq!
			tags = tagArray.join(INTER_TAG_DELIM.to_s)
			date = DateTime.now
			filename = HOME_DIR.to_s + "/" + date.year.to_s + DATE_FIELD_DELIM + date.month.to_s + DATE_FIELD_DELIM + date.day.to_s + DATE_TAG_DELIM + tags
			if FileSystemInterface.editFile(filename) == 0
				puts "Registered new note"
			end
		else
			puts "Did not register note. At least one tag is required."
		end
	end
	
	def NoteHandler.edit(params=[])
		searchTags = Formatting.flattenParams(params)
		fileList = NoteHandler.findRelevantNotes(searchTags)

		count = 0
		for i in 0..fileList.length-1
			filename = fileList[i]
			printf "Edit %s? (Y/n) ", Formatting.formatFilename(filename)
			userInput = gets.chomp
			if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
				FileSystemInterface.editFile(HOME_DIR.to_s + "/" + filename)
				count = count+1
			end
		end

		puts "Total " + count.to_s + " note(s) edited"
	end

	def NoteHandler.archive(params=[])
		searchTags = Formatting.flattenParams(params)
		fileList = NoteHandler.findRelevantNotes(searchTags)

		count = 0
		for i in 0..fileList.length-1
			entry = fileList[i]
			printf "Archive %s? (Y/n) ", Formatting.formatFilename(entry)
			userInput = gets.chomp
			if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
				Note.archive(entry)
				count = count+1
			end
		end

		puts "Total " + count.to_s + " note(s) archived"
	end
	
	def NoteHandler.recover(params=[])
		searchTags = Formatting.flattenParams(params)
		fileList = NoteHandler.findRelevantNotes(searchTags, true)	# Look into archive folder instead

		count = 0
		for i in 0..fileList.length-1
			entry = fileList[i]
			printf "Recover %s? (Y/n) ", Formatting.formatFilename(entry)
			userInput = gets.chomp
			if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
				Note.recover(entry)
				count = count+1
			end
		end

		puts "Total " + count.to_s + " note(s) recovered"
	end
	
	# FIXME: Needs a revamp of syntax and implementation
	def NoteHandler.tag(params=[])
 		searchTags = Formatting.flattenParams(params, false)

		noteMatchTags = []
 		for i in 0..searchTags.length-1
 			if searchTags[0] != "+" && searchTags[0] != "-"
 				noteMatchTags.push searchTags.shift
 			else
 				break
 			end
 		end

		count = 0
		fileList = NoteHandler.findRelevantNotes(noteMatchTags)
		for i in 0..fileList.length-1
			entry = fileList[i]
			printf "Tag %s? (Y/n) ", Formatting.formatFilename(entry)
			userInput = gets.chomp
			if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
				if Note.tagNote(fileList[i], searchTags) == true
					count = count+1
				end
			end
		end
 
 		puts "Changed tags for " + count.to_s + " note(s)"
	end
	
	def NoteHandler.findRelevantNotes(searchTags=[], archiveFolder=false)
		matchingFiles = Array.new

		searchFolder = HOME_DIR.to_s
		if archiveFolder == false
			if searchTags[0] == "recent"
				filename = FileSystemInterface.getRecentFile()
				if filename != ""
					matchingFiles.push(filename)
				end

				return matchingFiles
			end
		else
			# Searching in the archive folder
			searchFolder = searchFolder + "/.archive/"
		end

		Dir.foreach(searchFolder) do |entry|
			if entry != "." && entry != ".." && entry != ".archive"
				fields = entry.split(DATE_TAG_DELIM)
				dateString = fields[0]
				tagString = fields[1..fields.length()-1].join(DATE_TAG_DELIM).gsub(INTER_TAG_DELIM.to_s, ', ')
				tags = tagString.split(INTER_TAG_DELIM.to_s)
				tags.push dateString

				if (TagProcessing.findMatch(tags, searchTags))
					matchingFiles.push(entry)
				end
			end
		end

		return matchingFiles
	end

	def NoteHandler.list(params=[])
		searchTags = Formatting.flattenParams(params)

		if searchTags [0] == "archive"
			searchTags.shift
			fileList = NoteHandler.findRelevantNotes(searchTags, true)	# Searching in the archive folder
		else
			fileList = NoteHandler.findRelevantNotes(searchTags)
		end

		fileList.sort!
		for i in 0..fileList.length-1
			puts Formatting.formatFilename(fileList[fileList.length-1-i])
		end

		puts "Total " + fileList.count.to_s + " note(s) displayed"
	end
	
	def NoteHandler.print(params=[])
		searchTags = Formatting.flattenParams(params)

		fileList = NoteHandler.findRelevantNotes(searchTags)
		for i in 0..fileList.length-1
			Note.print(fileList[i])
		end

		puts "Total " + fileList.length.to_s + " notes(s)"
	end
	
	def NoteHandler.merge(params=[])
		searchTags = Formatting.flattenParams(params)

		newTags = []
		noteTags = []
		mergeFileList = []
		fileList = NoteHandler.findRelevantNotes(searchTags)
		for i in 0..fileList.count-1
			entry = fileList [i]
			printf "Use " + Formatting.formatFilename(entry) + " for merging? (Y/n) "
			userInput = gets.chomp.strip
			if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
				newTags = newTags | TagProcessing.getTags(entry)
				mergeFileList.push entry
			end
		end

		Note.merge(mergeFileList, newTags)
	end
	
	def NoteHandler.handleUnknownCommand(command)
		puts "Unknown command: '" + command + "'"
		Process.exit
	end
end

def tagSingleNote(filename, searchTags)
	fields = filename.split(DATE_TAG_DELIM)
	dateString = fields[0]
	tagString = fields[1..fields.length()-1].join(DATE_TAG_DELIM).gsub(INTER_TAG_DELIM.to_s, ', ')
	tags = tagString.split(INTER_TAG_DELIM.to_s)

	if searchTags.empty?
		printf "Add(+) / Remove(-) tags (default: +)? "
		operation = gets.chomp
		if operation.empty?
			operation = "+"
		end
	else
		operation = searchTags.shift
	end

	if searchTags.empty?
		printf "Tags to be added or removed: "
		searchTags = Formatting.splitQuottedStrings(gets.chomp.strip)
		if searchTags.empty?
			return false
		end
	end

	if operation == "+"
		# Add tag
		tags = tags | searchTags

		if NOCOLOR
			printf "Add tag(s) \'" + searchTags.join('\', \'') + "\' for %s? (Y/n) ", Formatting.formatFilename(filename)
		else
			printf "Add tag(s) \033[10;32m" + searchTags.join(', ') + "\033[0m for %s? (Y/n) ", Formatting.formatFilename(filename)
		end
	else
		if operation == "-"
			# Remove tag
			tags = tags - searchTags

			if NOCOLOR
				printf "Remove tag(s) " + searchTags.join(', ') + " for %s? (Y/n) ", Formatting.formatFilename(filename)
			else
				printf "Remove tag(s) \033[10;32m" + searchTags.join(', ') + "\033[0m for %s? (Y/n) ", Formatting.formatFilename(filename)
			end			
		else
			Formatting.printErr "Invalid command, expecting '+' or '-' after 'recent'\n"
			return false
		end
	end

	userInput = gets.chomp
	if userInput.empty? || userInput.downcase == "yes" || userInput.downcase == "y"
		File.rename(HOME_DIR.to_s + "/" + filename, HOME_DIR.to_s + "/" + dateString + DATE_TAG_DELIM + tags.join(INTER_TAG_DELIM.to_s))
		return true
	else
		return false
	end
end

Misc.driver()